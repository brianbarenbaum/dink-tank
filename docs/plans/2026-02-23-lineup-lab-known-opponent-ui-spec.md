# Lineup Lab Known-Opponent UI Specification

**Date:** 2026-02-23  
**Status:** Implemented (2026-02-23)  
**Related Plan:** `docs/plans/2026-02-22-lineup-lab-optimizer-improvements-v2.md`

---

## Goal

Define the standalone Lineup Lab UX for Blind and Response-to-Opponent modes so Phase 2 can ship UI first, then backend mode logic, without rework or input/output confusion.

---

## Fixed Product Decisions

1. App has two top-level tabs: `Chat` and `Lineup Lab`.
2. `Chat` is the default landing tab.
3. Chat and Lineup Lab are fully independent:
   - no lineup recommendation cards in chat
   - no lineup payloads sent to chat
4. Mode toggle lives in left sidebar under `Matchup`.
5. `Blind` mode still shows Opponent Roster, but:
   - opponent roster is not draggable
   - schedule cards do not show opponent assignment slots
6. Metadata is displayed at the top of Schedule Configuration:
   - Expected Wins
   - Conservative Wins
   - Matchup Win %
   - Game Confidence
   - Matchup Confidence
7. In `Response to Opponent` mode, all 8 rounds must be fully assigned before `Calculate` can run.

---

## Approach Selection

### Option A (recommended): Split Input and Output Surfaces
- Opponent input and optimizer output are visually and behaviorally separate.
- Prevents users from thinking they are manually editing both sides of a matchup.
- Aligns with known-opponent deterministic intent.

### Option B: Single unified editable grid
- Faster to build initially.
- Higher confusion risk: users cannot reliably infer what is input vs generated.

### Option C: Wizard (step-by-step screens)
- Lowest ambiguity.
- Slower operationally for captains and less aligned with the dense desktop design.

**Selected:** Option A.

---

## Screen Architecture

## Top Navigation

- `Chat` tab
- `Lineup Lab` tab
- Tab switch preserves local state per tab.

## Lineup Lab Layout

- Left rail: context controls + calculate action.
- Center-left column: Team Roster (availability toggles) + Opponent Roster.
- Main board: Schedule Configuration (8 rounds) + metadata header.

---

## Component Contract

## `LineupLabTabShell`

Responsibilities:
- Own Lineup Lab route-level layout.
- Compose sidebar, roster panels, metadata header, schedule board.
- Orchestrate loading and empty/error states.

## `LineupLabSidebar`

Controls:
- Division selector
- Team selector
- Matchup selector
- Mode toggle (under Matchup): `Blind` | `Response to Opponent`
- Calculate button

Rules:
- Calculate disabled when required context is incomplete.
- In `Response to Opponent`, calculate disabled until all 8 rounds are fully and validly assigned.

## `TeamRosterPanel`

- Shows selected team players with availability toggles.
- Availability changes update `availablePlayerIds`.

## `OpponentRosterPanel`

- Always visible.
- `Blind` mode: static list, non-draggable.
- `Response to Opponent`: draggable/selectable source for opponent assignment.

## `ScheduleMetadataHeader`

- Displays top-of-board metrics only.
- Uses latest recommendation result.
- Shows placeholder state before first calculation.

## `ScheduleConfigurationBoard`

- 8 rounds, fixed pattern:
  - R1 mixed x4
  - R2 female x2 + male x2
  - repeat alternating through R8
- Each round card shows:
  - round label
  - match type label per slot
  - our lineup output slot (read-only generated result)
  - win probability (when result exists)
- Opponent assignment slots:
  - hidden in `Blind`
  - visible in `Response to Opponent`

## `OpponentLineupInput` (in-board or board-adjacent)

- Captures opponent pair assignments by round/slot.
- Supports drag-drop and click-select assignment.
- Enforces one opponent player per slot position and no duplicate players within a game.

---

## Mode Behavior Matrix

## Blind Mode

1. Opponent roster visible, non-interactive.
2. No opponent drop zones rendered in round cards.
3. Calculate uses blind payload shape (`mode: "blind"`).
4. Board displays generated lineup output only after recommendation.

## Response to Opponent Mode

1. Opponent roster visible and interactive.
2. Opponent assignment zones rendered for each slot in each round.
3. Validation requires complete and valid assignments for all 8 rounds.
4. Calculate uses known-opponent payload shape (`mode: "known_opponent"`, `opponentRounds`).

---

## Input/Output Anti-Confusion Rules

1. Two persistent lane labels at board top:
   - `Captain Input`
   - `Optimizer Output`
2. Opponent assignments are always shown in `Captain Input` lane.
3. Our lineup is always shown in `Optimizer Output` lane.
4. `Optimizer Output` is read-only (lock icon + text: `Generated by optimizer`).
5. Before calculation, output lane shows explicit placeholder: `No generated lineup yet`.
6. In Blind mode, input lane for opponent is replaced with `Hidden in Blind Mode`.

---

## State Model

## Core UI State

- `activeTab: "chat" | "lineup_lab"`
- `mode: "blind" | "known_opponent"`
- `selectedDivisionId`
- `selectedTeamId`
- `selectedMatchupId`
- `availablePlayerIds[]`
- `opponentAssignments` (round -> slot -> pair), required in known mode
- `recommendationResult` (nullable)
- `uiErrors[]`

## Derived State

- `isKnownMode = mode === "known_opponent"`
- `isOpponentInputComplete`
- `canCalculate`
- `metadataViewModel`

---

## Validation and Error UX

## Pre-submit validation

- Team availability rules (min/even count).
- Known mode requires complete `opponentAssignments` for all 8 rounds.
- Slot pattern validity:
  - 8 rounds
  - 4 games each round
  - round type pattern must match fixed schedule.

## Error presentation

- Inline errors near source control when possible.
- Sticky summary message above Calculate button for blocking errors.
- API validation errors mapped to user-readable messages, preserving field context.

---

## Responsive Behavior

## Desktop

- Three-column layout (left controls, roster column, schedule board).
- Drag-drop opponent assignment enabled in known mode.

## Mobile

- Stack sections vertically:
  - controls
  - roster panels
  - schedule board
- Opponent assignment supports tap-to-assign fallback (no drag required).

---

## Delivery Sequence (UI-First)

1. Build top-tab architecture and isolate Chat from Lineup Lab.
2. Implement Lineup Lab shell, sidebar, roster panels, schedule board scaffold.
3. Implement mode toggle behavior and anti-confusion visual boundaries.
4. Implement known-mode opponent input interactions in UI state only.
5. Wire backend request schema and validation for `mode` and `opponentRounds`.
6. Enable known-mode calculate with backend deterministic path.

Transitional behavior:
- During UI-only steps, `Response to Opponent` can render full interaction but show calculate as disabled until backend mode endpoint is ready.

---

## Frontend-Only Playwright Strategy (Before Backend Phase 2)

## Objective

Make the Lineup Lab UI fully testable before backend mode/optimizer updates are complete.

## Strategy

### Track A (recommended immediate): Playwright route mocking

- Use `page.route()` in E2E specs to intercept:
  - `**/api/lineup-lab/context/divisions`
  - `**/api/lineup-lab/context/teams*`
  - `**/api/lineup-lab/context/matchups*`
  - `**/api/lineup-lab/recommend`
- Return deterministic fixture JSON from local files.
- This requires no backend runtime changes and works with existing Playwright config.

### Track B (optional for manual QA): Frontend mock adapter

- Add a UI-only environment flag (example: `VITE_LINEUP_LAB_MODE=mock`).
- In mock mode, Lineup Lab client resolves fixture payloads directly.
- Keep this flag disabled in production builds.

**Selected baseline:** Track A first. Add Track B only if manual design QA needs faster iteration without test harness.

## Fixture Contract (for stable E2E)

Create fixtures under `e2e/fixtures/lineup-lab/`:
- `divisions.json`
- `teams.json`
- `matchups.json`
- `recommend-blind.json`
- `recommend-known-opponent.json`
- `recommend-validation-error.json`

Rules:
- Use deterministic UUIDs and player names.
- Include one full 8-round known-opponent assignment set.
- Include one partial/invalid assignment payload to test disabled/error states.

## Required `data-testid` Hooks

Navigation and tab state:
- `top-tab-chat`
- `top-tab-lineup-lab`
- `lineup-lab-root`

Sidebar and context:
- `lineup-division-select`
- `lineup-team-select`
- `lineup-matchup-select`
- `lineup-mode-toggle-blind`
- `lineup-mode-toggle-known-opponent`
- `lineup-calculate-button`

Roster panels:
- `team-roster-panel`
- `opponent-roster-panel`
- `opponent-roster-item-<playerId>`

Schedule and metadata:
- `schedule-metadata-header`
- `schedule-expected-wins`
- `schedule-conservative-wins`
- `schedule-matchup-win-probability`
- `schedule-game-confidence`
- `schedule-matchup-confidence`
- `round-card-<roundNumber>`
- `round-slot-<roundNumber>-<slotNumber>-opponent-input`
- `round-slot-<roundNumber>-<slotNumber>-optimizer-output`

Validation and state:
- `known-opponent-completion-error`
- `optimizer-output-empty-state`

## Playwright Spec Matrix

Create `e2e/lineup-lab-ui-mock.spec.ts` with:

1. `tab separation`: default opens Chat; switching to Lineup Lab does not render chat transcript content in lineup surface.
2. `blind mode layout`: opponent roster visible, non-draggable; no opponent input slots rendered.
3. `known mode layout`: opponent input slots rendered; roster items interactive.
4. `known mode completion gate`: calculate disabled until all 8 rounds are fully assigned.
5. `blind calculate flow`: mocked recommend response populates metadata header and optimizer output.
6. `known calculate flow`: mocked known-opponent response populates metadata/output after full assignment.
7. `validation error mapping`: mocked 400 error displays field-aware blocking error.
8. `mobile parity`: viewport test confirms mode toggle and completion gate behavior on narrow screens.

## Execution Commands

- Run only Lineup Lab mock E2E:  
  `npx playwright test e2e/lineup-lab-ui-mock.spec.ts`
- Run all E2E:  
  `npm run test:e2e`

## CI Gate Recommendation

- Add Lineup Lab UI mock spec to required checks for Phase 2 UI PRs.
- Backend integration tests can remain optional until Phase 2 backend steps (`2.3+`) are complete.

---

## Mandatory Completion Gate (LLM Implementation Rule)

Any Lineup Lab UI task is **not complete** until Playwright validates both:
1. Spec compliance (behavior/state contracts in this document).
2. Design parity (layout/visual hierarchy against `designs/lineup_lab_new.png`).

Required pass sequence before claiming completion:
1. `npx playwright test e2e/lineup-lab-ui-mock.spec.ts`
2. `npx playwright test e2e/lineup-lab-ui-visual.spec.ts`

Implementation requirements:
- `e2e/lineup-lab-ui-visual.spec.ts` must use deterministic mocked data and fixed viewport(s).
- Visual assertions must use Playwright screenshot expectations (for example `toHaveScreenshot`) against approved baselines.
- At minimum include desktop visual parity for Lineup Lab tab; include mobile if mobile layout is changed.
- If dynamic elements exist, mask or stabilize them so visual tests are deterministic.

Failure policy:
- If any required Playwright assertion fails, the task remains in-progress.
- The implementer must continue iterating on code and re-running Playwright until all required checks pass.
- Do not mark task done, fixed, or complete while any required UI Playwright check is failing.

Evidence required in completion report:
- Commands run.
- Pass/fail summary (test counts).
- Paths to generated artifacts/screenshots when applicable.

---

## Verification Checklist

1. Chat launches as default tab and has no lineup UI.
2. Lineup Lab can run blind calculations without any opponent assignment UI.
3. Switching to known mode reveals opponent assignment UI and validation.
4. Blind mode removes opponent slots from schedule cards and disables roster drag.
5. Metadata appears only in top schedule header and updates after calculation.
6. Users can identify input vs output areas in under 3 seconds in usability review.

---

## Open Questions

1. In known mode, should we allow duplicate opponent players across multiple rounds if that reflects real constraints, or enforce global uniqueness limits in UI?
